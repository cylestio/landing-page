<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How You Can Build a Secure MCP Registry in One Evening | Cylestio Blog</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E54G06JMKM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-E54G06JMKM');
    </script>
    <link rel="stylesheet" href="../blog.css">
    <link rel="icon" href="../../favicon.ico">
    <meta name="description" content="Learn how to build a Complex Product in one evening with a multi-agent framework with this step-by-step guide.">
    <style>
        .header-flex {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        .header-image {
            width: 240px;
            height: 240px;
            object-fit: cover;
            flex-shrink: 0;
            border-radius: 8px;
        }
        .header-content {
            flex-grow: 1;
        }
        .header-content h1 {
            margin-top: 0;
        }
        
        @media (max-width: 768px) {
            .header-flex {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }
            .header-image {
                width: 100%;
                height: auto;
                max-height: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="blog-container">
        <header class="blog-header">
            <div class="header-flex">
                <img src="../images/multi_agent.png" alt="MCP Registry Interface" class="header-image">
                <div class="header-content">
                    <h1>How I used a team of 15 agents with 4 prompts</h1>
                    <p class="post-meta">April 17, 2025</p>
                </div>
            </div>
            <p><a href="../">‚Üê Back to Blog</a></p>
        </header>
        
        <main>
            <p>I keep seeing people ask about how to use coding agents for more complex products that involve:</p>
            <ul>
                <li>Algorithms (ML, scoring, reputation, graphs‚Ä¶)</li>
                <li>Databases, APIs, or scheduled jobs</li>
                <li>Multi-component systems (backend + frontend + SDKs + MCPs)</li>
                <li>Low-level or infrastructure-focused tools</li>
            </ul>
            <p>üëâ This is exactly what we're getting into now.</p>
            <p>(Other topics like release pipelines, security, testing, auth, and compliance are coming soon.)</p>
            <p>So here it is: a real product, built from scratch, using only multi-agent prompts ‚Äî including real data fetching, a working DB, backend and frontend logic, and UI.</p>

            <hr>

            <h2>ü§ñ The Multi-Agent Framework, Step by Step</h2>

            <p>Each agent has awareness of the broader process ‚Äî not just its own task.</p>
            <p>Learning from how different teams work together, there's value in differentiating roles and ensuring they orchestrate well.</p>
            <p>The Product Manager doesn't just define a spec ‚Äî it also adds instructions for the Architect, Designer, and Dev Lead.</p>
            <p>The Dev Lead decides how many developers it needs for the task, what their execution order should be, and where their task boundaries lie.</p>
            <p>Each agent works with context, not just instructions:</p>
            <ul>
                <li>Its role and responsibility in the overall flow</li>
                <li>Which agents worked before, and what they produced</li>
                <li>Who it's collaborating with next, and what they'll need</li>
                <li>What model it's running on, and how to tailor its output accordingly</li>
                <li>How to share context continuously, like teams syncing in daily standups</li>
            </ul>
            <p><strong>This isn't just chaining prompts ‚Äî it's about shared knowledge</strong></p>
            <p>The agents are aware of each other, collaborate asynchronously, and build on one another's work like a team that's always in sync.</p>
            <p>It's very basic, but works surprisingly well.</p>
            <p>The flow can also be extended into branching paths, feedback loops, and fully autonomous systems.</p>

            <hr>

            <h2>üß† The Methodology</h2>

            <p>Here's how the flow works:</p>

            <ol>
                <li>
                    <strong>Executive ‚Üí Product Manager</strong><br>
                    I wrote a short business goal. That was the only input needed. The rest was already inside the prompt template.
                </li>
                <li>
                    <strong>Product Manager ‚Üí Architect</strong><br>
                    The agent read the spec and defined the architecture, tech stack, and main components.
                </li>
                <li>
                    <strong>Product Manager & Architect ‚Üí Designer</strong><br>
                    Created a design system and flow description in markdown ‚Äî no Figma needed (yes, I know the product designers are doing much more than that, I just simplified it here for our example).
                </li>
                <li>
                    <strong>Designer & Architect & Designer ‚Üí Dev Team Lead</strong><br>
                    Broke the implementation into tasks, each with full context, test instructions, and checklist.
                </li>
                <li>
                    <strong>Dev Team Lead ‚Üí Executors</strong><br>
                    Each task was executed by Claude 3.7 or 3.5 Sonnet, which read the spec, implemented the logic, tested it, and logged results.
                </li>
            </ol>

            <p>All of this was done in Cursor. Each output was saved to a markdown file in a dedicated directory.</p>

            <p>üìÇ You can check out the prompt templates here:<br>
            üëâ <a href="https://github.com/omrilahav/vibe-coding" target="_blank">github.com/omrilahav/vibe-coding</a></p>

            <hr>

            <h2>üõ† The Demo: MCP Registry & Reputation Explorer</h2>

            <p>To showcase the process (I'm working on a much larger-scale product that will be released soon using the multi-agent framework), I picked a realistic project ‚Äî something that usually breaks in no-code environments:</p>
            <ul>
                <li>Reputation algorithm</li>
                <li>Real API access</li>
                <li>Fetching + storing real data</li>
                <li>Scheduling</li>
                <li>Clean UI</li>
                <li>Design system</li>
                <li>A working backend + database</li>
            </ul>

            <p>The MCP Registry app scans for real MCP servers, pulls metadata, calculates a reputation score, and displays it in a dynamic UI ‚Äî to help teams select trustable sources.</p>

            <hr>

            <h2>üìè It Took Just a Short Evening</h2>

            <p>From empty repo to working product ‚Äî the whole process took less than a few hours.</p>

            <p>Some tasks didn't work on the first try. I copied the error message back into the task prompt, ran it again, and it worked. The agents handled most things really well.</p>

            <p>To keep it simple, I only used the Glama MCP API as a source. The pagination didn't work properly, so the app only shows part of the results ‚Äî but for the scope of the demo, that was fine.</p>

            <p>Future versions could include:</p>
            <ul>
                <li>More sources (GitHub scraping, enrichment)</li>
                <li>Feedback scoring and reputation signals</li>
                <li>More polished frontend interactions</li>
            </ul>

            <p>But the goal here was to show the process clearly.</p>

            <hr>

            <h2>üß≠ Want to Try It Yourself?</h2>

            <ol>
                <li>
                    Clone the framework repo:<br>
                    üëâ <a href="https://github.com/omrilahav/vibe-coding" target="_blank">github.com/omrilahav/vibe-coding</a>
                </li>
                <li>Pick a project or feature idea you want to try.</li>
                <li>
                    Go to <code>1-product-manager.md</code>, and write your business goal in the placeholder.
                    <ul>
                        <li>You can see the example input I used <a href="https://github.com/omrilahav/vibe-coding-demo-mcp-registry/blob/main/demo-methodology-files/input-product-manager.md" target="_blank">here</a></li>
                    </ul>
                </li>
                <li>Run the prompt in Claude 3.7 Sonnet (Cursor is what I used)</li>
                <li>Save the output in <code>product/</code>, then move on to the next prompt (it already happens automatically for you)</li>
                <li>Repeat the process ‚Äî each agent reads the previous output and generates the next</li>
                <li>When the Dev Lead creates tasks, give each one to a new agent and run them in order</li>
            </ol>

            <p>You'll end up with a full set of outputs ‚Äî specs, architecture, design, code, and tests ‚Äî all created by AI agents, connected by context.</p>

            <hr>

            <h2>üìÅ What's in the Demo Repo</h2>

            <p>You can explore all of this in the demo repo.<br>
            Each folder contains actual agent output:</p>

            <ul>
                <li><code>product/</code> ‚Äî product spec, user stories, value props</li>
                <li><code>architecture/</code> ‚Äî stack choices, component diagrams, data flow</li>
                <li><code>design/</code> ‚Äî design system, screens, layout instructions</li>
                <li><code>tasks/</code> ‚Äî implementation plan + task-by-task execution logs</li>
                <li><code>demo-methodology-files/</code> ‚Äî prompt files + initial input</li>
            </ul>

            <p>The product works, even with limited data sources. More importantly, it shows how the agents collaborated to build it.</p>

            <hr>

            <h2>üöÄ What's Next</h2>

            <p>This is just one possible direction.<br>
            The same methodology can support:</p>
            <ul>
                <li>Feature requests and product growth</li>
                <li>CI/CD flows</li>
                <li>Secure development and SSDLC</li>
                <li>Agent-led QA and testing</li>
                <li>Monitoring and incident workflows</li>
            </ul>

            <p>The long-term goal is to create clear, open flows that allow agents to collaborate like systems ‚Äî with shared knowledge, scoped decisions, and well-defined responsibilities.</p>

        </main>
        <footer>
            <p class="post-meta">&copy; 2025 Cylestio. All rights reserved.</p>
        </footer>
    </div>
</body>
</html> 